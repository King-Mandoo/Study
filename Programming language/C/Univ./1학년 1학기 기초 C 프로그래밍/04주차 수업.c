2022. 03. 24 4주차 수업

🟡 데이터 형식과 배열

🟢 비트, 바이트, 진수

🔶 비트

--> 비트(bit)는 전기 스위치와 비슷한 개념이다. 전기 스위치에는 OFF와 ON만 있듯이 비트에도 0(off)과 1(on)만 있다.

🔶 진수

10진수: 0 1 2 3 4 5 6 7 8 9  /  10 11 12 13 14 15 16 17 18 19 / 20 21 22 23 ...
 8진수: 0 1 2 3 4 5 6 7  /  10 11 12 13 14 15 16 17  /  20 21 22 23 ...
16진수: 0 1 2 3 4 5 6 7 8 9 0A 0B 0C 0D 0E 0F  /  10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F / 20 21 22 23 ... 

                      * 16진수가 필요한 이유는 2진수의 네 자리와 16진수의 한 자리가 딱 맞아떨어지기 때문이다.
                      
                      
    * 2진수 --> 10진수        
      10진수 --> 2진수
      
      2진수 --> 16진수            
      16진수 --> 2진수           진수 변환법은 책 p. 93 ~ 95 읽기!!
      
      10진수 --> 16진수
      16진수 --> 10진수
                       
      
      16진수의 10과 2진수의 10은 다르다.
      
🔶 숫자형 데이터 형식      
                      
 --> 소수점의 유무에 따라 크게 정수형과 실수형으로 나눌 수 있다.   정수형과 실수형은 다시 조금씩 다른 데이터 형식으로 구분된다.                      
                      
		      
   short  -->  작은 정수형
   unsigned short --> 부호 없는 작은 정수형
   int --> 정수형 
   unsigned int --> 부호 없 자형 또는 부호 없는 정수형
   
 ----------------------------------------------------------------------  
   
   #include <stdio.h>

int main()
{
	int a = 100, b = 200;           

	float result;                   
	result = a / b;

	printf("%f", result);      -->  출력값:  0.000000   
}
                                        이유:  정수끼리 연산을 수행하면 그 결과도 정수가 되기 때문이다.
                                                 ❗❗❗ 실수가 하나라도 들어가면 그 결과는 실수가 된다. ❗❗❗
                      
    #include <stdio.h>

int main()
{
	int a = 100;
	float b = 200;             <--- 자료형을 실수로 고쳐준다.

	float result;
	result = a / b;

	printf("%.1f", result);      --> 출력값:  0.5
}
   
   
   

🔶 문자형 데이터 형식

  -->  일반 글자를 표현할 수 있는 데이터 형식에는 문자형과 문자열이 있다.
       🔅문자열은 별도의 데이터 형식이 아니며🔅 문자의 집합 정도로 생각하면 된다.

* 아스키코드

  --> ASCII (American Standared Code for Information Interchange)  = 미국정보교환표준부호
      
      사람과 컴퓨터의 정보 교환을 위한 표준화된 코드

* 한 글자를 뜻하는 문자형

  --> 문자형은 문자 또는 기호 하나를 저장하는 형식을 말한다.
  
  char  -->  문자형 또는 정수형
  unsigned char  -->  문자형 또는 부호 없는 


      *char 형에는 문자뿐만 아니라 값의 범위에 해당하는 정수를 대입할 수 있다.
      즉, char 형을 1바이트 크기의 정수형으로 취급해도 상관없다.
      
      ✅printf("%d\n", 'A');    -->   65 로 출력.
         printf("%c\n", 65);     -->  A로 출력.
 
#include <stdio.h>

int main()
{
	int a;                         <---- a와 b의 변수형이 달라도  변수 사이에 대입이 된다. 
	char b;

	a = 65;
	b = a;
 
       printf("%c", a)                 <-----     정수형 변수 a를 문자형으로 출력했는데 아스키코드 값인 'A'가 출력된다. 
	                                          즉, 입력하는 값이 0 ~ 127이라면 정수형 변수(int)도 문자형으로 출력할 수 있다.
       printf("%d", b);      <-- 65로 출력          
}

            ❗❗❗ 'A'와 65는 동일한 값이지만 어떤 출력 서실을 사용하느냐에 따라 다른 값이 출력된다. ❗❗❗


🔶 여러 글자가 모인 문자열과 배열

  -->  문자열은 '문자형 집합'의 개념으로 "문자열"이라는 데이터 형식이 따로 존재하지 않는다.
       문자형 데이터 형식 char는 한 글자만 저장할 수 있다고 했으며, 문자열은 한 문자가 여러 개 이어진 것이라고 생각하면 된다.
       
*문자열의 기본형식

  --> 문자열을 저장하려면 최소한 문자열의 길이에 1을 더한 자릿수가 필요하다. 즉 여섯 글자를 저장하려면 최소한 일곱 자리가 필요하다는 뜻이다.
      그 이유는 이 문자열이 끝난다는 것을 표시하는 널(null) 문자('\0')가 끝에 들어가야 하기 때문이다.
      
      널 문자는 문자열의 끝을 알려주는 중요한 역할을 한다.  '\'와 '0'을 합친 널 문자는 하나의 문자로 취급하지만 화면에는 출력되지 않는다.
      
      ✅char str[7];   <--  str 라는 변수에 문자형 7개를 배열함.
      
         str[0] ~ str[6] 이다. (배열이 0부터 시작한다.)

-------------------------------------------------------

#include <stdio.h>
#include <string.h>

int main()
{
	char str1[10];                   <---  문자형 배열 str1과 str2 선언 
	char str2[10];
	char str3[10] = "CookBook";      <--- 문자형 배열 str3을 선언함과 동시에 문자열을 대입

	strcpy(str1, "Basic-C");             <--- str1에 문자열 "Basic-c"를 대입
	strcpy(str2, str3);                  <--- str2에 str3를 대입

	printf("str1 --> %s\n", str1);               <--- 문자형 배열 출력
	printf("str2 --> %s\n", str2);
	printf("str3 --> %s\n", str3);
}

       ✅ str1  ->  B a s i c - C \0 _ _            <-- 10개의 배열 안에 2칸이 남음
           
	   str2  ->  C o o k B o o k \0 _            <-- 10개의 배열 안에 1칸이 남음

            str3  ->  C o o k B o o k \0 _            <-- 10개의 배열 안에 1칸이 남음
 


------------------------------------------------------------------------


#include <stdio.h>

int main()
{
	char str[10] = "0123456789";                 <--  열 자리의 str배열에 글자 0123456789 (10개)를 대입한다.

	printf("str==> %s \n", str);

	str[0] = 'I';                        <--  str 배열에 글자 6개와 널 문자를 입력한다.
	str[1] = 'T';
	str[2] = 'C';
	str[3] = 'o';
	str[4] = 'o';
	str[5] = 'k';
	str[6] = '\0';                       <-- 널문자를 입력해주지 않으면 ITCook6789 이렇게 입력돼서 뒤에 쓰레기 값이 출력된다.

	printf("str ==> %s \n", str);
	printf("str[7] ==> %c \n", str[7]);
	printf("str[50] ==> %c \n", str[50]);
}
                
                                 널 문자(\0)은 문자열을 출력할 때 자동차의 브레이크와 같은 역할을 한다. 
				 
				 c언어에서 문자열은 다른 변수와 달리 길이가 가변적이기 때문에 컴파일러가 특별한 취급을 해줍니다.
				 문자열을 저장하는 메모리를 따로 가지고 있고 문자열 자체를 그 메모리에 저장되었을 때의 첫 문자의 주소가 됩니다. 
				 그 때 문자열을 끝을 표시해 주어야 하는데 널문자가 이 역할을 합니다.
				 
                                 char str[10] = "0123456789";    <-- 열 자리의 배열에 10개의 문자가 들어가기 때문에 널 문자가 들어갈 자리가 없다.
                                 printf("str==> %s \n", str);        따라서 배열 str을 출력할 때 뒤에 이상한 쓰레기값이 출력 되는 것이다.
				 
          출력값:    str==> 0123456789儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆儆픟Q???  
                    str ==> ITCook
                    str[7] ==> 7
                    str[50] ==> ?     <-- 선언한 범위를 넘어서도 첨자는 사용할 수 있다. 물론 출력된 값은 예상할 수 없는 이상한 값이다.


----------------------------------------------------------------------------------------------------------------------------------------------------------------

📌예제 문제풀이📌

예제 04.  맞음⭕

#include<stdio.h>

int main()
{
	int a;

	printf("정수를 입력하세요 ==> ");
	scanf("%d", &a);

	printf("16진수 ==> %x\n", a);          // 정수 a를 16진수로 소문자로 출력
	printf("16진수 ==> %X\n", a);          // 정수 a를 16진수로 대문자로 출력
	printf("8진수 ==> %o\n", a);          // 정수 a를 8진수로 출력
	printf("10진수 ==> %d", a);          // 정수 a를 10진수로 출력
}




예제 05.  애매함❗❓

#include <stdio.h>

int main(void)
{
	int num;
	int data;

	printf("입력진수 결정 <1>10 <2>16 <3>8 : ");
	scanf("%d", &num);

	printf("값 입력 : ");
	scanf("%d", &data);

	if (num == 1)
	{
		printf("%d\n", data);
	}
	else if(num == 2)
	{
		printf("%X\n", data);          //내가 data에 65를 입력을 했는데 왜 A가 안나오지 라는 생각을 했다. 그니까 16진수랑 아스키 코드 즉, 문자형이랑 헷갈렸다. 
	}                                        10진수 65를 16진수로 변환하면 41이다. 그건 65를 16으로 나눠보면 4로 나뉘고 나머지가 1이기 때문이다.
	else if(num == 3)
	{
		printf("%o\n", data);
	}

	printf("10진수 ==> %d \n", data);
	printf("16진수 ==> %X \n", data);
	printf("8진수 ==> %o \n", data);
	printf("문자형 ==> %c \n", data);
}

🔻고친 답🔻

#include <stdio.h>

int main(void)
{
	int num;
	int data;

	printf("입력진수 결정 <1>10 <2>16 <3>8 : ");
	scanf("%d", &num);

	printf("값 입력 : ");

	if (num == 1)
	{
		scanf("%d", &data);
	}
	else if(num == 2)
	{
		scanf("%X", &data);      
	}
	else if(num == 3)
	{
		scanf("%o", &data);
	}

	printf("10진수 ==> %d \n", data);
	printf("16진수 ==> %X \n", data);
	printf("8진수 ==> %o \n", data);
	printf("문자형 ==> %c \n", data);
}



예제 06.  맞음⭕       <-- 먼 개 노가다냐..?

#include <stdio.h>

int main()
{
	printf("int 형의 크기 \t\t\t==> %d\n", sizeof(int));
	printf("unsigned int 형의 크기 \t\t==> %d\n", sizeof(unsigned int));
	printf("short 형의 크기 \t\t==> %d\n", sizeof(short));
	printf("unsigned short 형의 크기 \t==> %d\n", sizeof(unsigned short));
	printf("long int 형의 크기 \t\t==> %d\n", sizeof(long int));
	printf("unsigned long int 형의 크기 \t==> %d\n", sizeof(unsigned long int));
	printf("float 형의 크기 \t\t==> %d\n", sizeof(float));
	printf("double 형의 크기 \t\t==> %d\n", sizeof(double));
	printf("long double 형의 크기 \t\t==> %d\n", sizeof(long double));
	printf("char 형의 크기 \t\t\t==> %d\n", sizeof(char));
	printf("unsigned char 형의 크기 \t==> %d\n", sizeof(unsigned char));
}




예제 07. 틀림❌  

🔻고친 답🔻

#include <stdio.h>

int main()
{
	char line[10]=" ";       < --- ✅ 3. char line[10]=" "; 와  char line[10]; 의 값이 왜 다르게 나올까? 후자에서는 뒤에 쓰레기 값이 붙어서 나온다. 그 이유가 뭘까?

	printf("문자열을 입력 ==> ");                          ✅ 틀린 이유
	scanf("%s", line);                                     1. %c와 %s를 구분하지 못했다.    
                                                                  %c로 입력받으면 제일 앞의 문자만 입력받게 되고, %s로 받으면 하나의 단어로 입력을 받을 수 있게 된다. 
	printf("\t");                                             따라서 %c로 apple을 치게 되면 a만 출력되고 %s로 apple를 치게 되면 apple이 출력되는 것이다.
	printf("%c", line[9]);
	printf("%c", line[8]);
 	printf("%c", line[7]);                                 2. 왜 scanf로 문자를 입력을 받을 떼, 일반 int형 변수의 경우에는 앞에 &를 붙여서 받지만 문자열은 그렇지 않을까?
                                                                  scanf("%s", line); <-- 왜 그럴까?
	printf("%c", line[6]); 
	printf("%c", line[5]);
	printf("%c", line[4]);
	printf("%c", line[3]);
	printf("%c", line[2]);
	printf("%c", line[1]);
	printf("%c", line[0]);
}

    ✅ 2번에 대한 답.  -->  &(앰퍼서드)는 해당 변수의 주소를 가리키는 역할을 한다.
                            scanf("%d", &a);
			    1. 값을 입력받는다.
			    2. 그 값을 레지스터에 임시로 저장하고 (* 레지스터란 임시의 저장공간이라고 생각하면 된다.)
			    3. 변수의 주소로 찾아가 그 주소가 가리키는 메모리에 레지스터에 있는 값(입력한 값)을 저장한다.
			    4. 레지스터에 있던 값은 지운다.
			    - 즉, 값을 입력하려면 변수의 주소가 필요하기 때문에 &를 써야한다.           //출처:https://security-nanglam.tistory.com/194
 
                            하지만 만약 문자열(%s)을 집어넣을 경우에는 문자열 자체가(변수가 포인터가나 배열 일때) 주소이므로 안써도 된다.
                            
			    * 배열은 주소의 의미를 내포하고 있다.
			      
			    Q. 배열의 주소는 어떻게 찾아가는가?   -->  https://blog.naver.com/tipsware/220992959841    읽어보기.
                              

    ✅ 3번에 대한 답.  -->   char line[10]=""; 을 하면 line[0]=0; 처럼 널문자만 배열에 넣은 것과 같다. (널문자는 NULL,'\0',0 등으로 표기)
                             그리고 line[1]부터 line[9]까지는 아무것도 지정해 주지 않았기 때문에 자동으로 0으로 초기화가된다.
			     그렇기에 0으로 초기화되어 있는 상태에서 scanf 함수로 입력을 받았고 
			     printf의 %c로 출력을 하게 되면 배열의 값이 0인 것은 %c로 출력되지 않는다.
			     
			     한편 초기화 없이 char line[10]; 배열을 선언할 경우, 일반적으로(특히 지역변수인 경우)
			     배열은 초기화되지 않고, 메모리가 가지고 있던 값을 쓰레기 값으로 가지고 있다.
			     따라서 초기화되지 않은 배열칸의 값이 %c로 출력되어 쓰레기 값이 보이게 되는 것이다.
			     
			     따라서 배열을 사용할 때는 널문자의 부재로 인해 발생할 수 있는 쓰레기 값을 예방하기 위해
			     처음에 널문자로 초기화를 하는 것이 좋다.


🔻답지 답🔻

#include <stdio.h>

int main()
{
	char line[10] = "";
	int i;

	printf("문자열을 입력 ==> ");
	scanf("%s", line);         

	for (i = sizeof(line) - 1; i >= 0; i--)          <-- for 문에 대한 설명은 아래에   // 근데 난 굳이 초기화 코드를 i = sizeof(line) - 1; 이렇게 해야하나 싶다.
	{                                                                                    i = 9; 이게 더 쉽고 편해보인다.
		printf("%c", line[i]);
	}

	printf("\n");
}



✅ for (초기화 코드; 반족 조건식; 증감문)
   {
                반복할 코드
   }
  
    // 헬로 코딩 p.248참고
    *초기화 코드: 반복문이 실행되기 전 딱 한번만 실행.
     반복 조건식: 조건식이 참이면 중괄호 사이의 코드를 실행시킴. 거짓이면 종료
     증감문: 중괄호 안의 코드를 한번 실행시킬때마다 코드가 실행된 뒤, 실행됨.


https://ko.wikihow.com/2%EC%A7%84%EC%88%98%EB%A5%BC-16%EC%A7%84%EC%88%98%EB%A1%9C-%EB%B0%94%EA%BE%B8%EB%8A%94-%EB%B2%95


----------------------------------------------------------------------------------------------------------------------------------------------------------------

💫나 홀로 고민.💫


#include <stdio.h>

int main()
{
	char line[10] = "";
	int i;

	printf("문자열을 입력 ==> ");
	scanf("%s", line);         

	for (i = sizeof(line) - 1; i >= 0; i--)         
	{                                                                                 
		printf("%c", line[i]);
	}

	printf("\n");
}

-------------------------------------------               이 두 코드의 차이점이 보이는가? 위에 있는 코드의 414번 줄과 아래 코드의 441줄,442번줄의 차이, 바로 ="" 이다
                                                          생각을 해봤다. 왜 아래코드는 널 문자를 자동으로 넣어주는데, 위의 코드는 널 문자를 내가 ="" 로 미리 채워넣어야
-------------------------------------------  		  하는 지를 말이다. 
							  내가 생각해낸 답은 이렇다.
-------------------------------------------  		  위의 코드는 scanf 함수를 통해 나의 입력을 받고 그 입력받은 값을 출력한다. 나는 널 문자를 입력하지 않았다.
							  하지만 아래 코드는 입력을 받는 것이 아니라 그저 출력을만을 하기 때문에 널 문자를 자동으로 넣고 출력하는 것이지 않을까?
-------------------------------------------  		  내 생각은 이렇다.

#include <stdio.h>
#include <string.h>

int main()
{
	char str1[10];                  
	char str2[10];
	char str3[10] = "CookBook";     

	strcpy(str1, "Basic-C");             
	strcpy(str2, str3);                

	printf("str1 --> %s\n", str1);         
	printf("str2 --> %s\n", str2);
	printf("str3 --> %s\n", str3);
}
